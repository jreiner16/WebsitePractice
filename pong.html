<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Jungle Pong</title>
    <style>
        :root {
            --bg: #0b2014;
            /* deep jungle green */
            --panel: #0d1a12;
            --ink: #e8ecf6;
            --muted: #b8c3b6;
            --line: #1c3427;
            --accent: #81e6a8;
            /* mint accent */
            --ball: #ffffff;
            --paddle-bark: #6d4b2d;
            /* brown paddle */
            --paddle-stripe: #2fb36b;
            /* green stripe */
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 700px at 50% -10%, #12301f 0%, var(--bg) 60%);
            color: var(--ink);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            display: grid;
            place-items: center;
        }

        .container {
            width: min(95vw, 960px);
            padding: 16px;
        }

        .controls {
            display: none;
        }

        button {
            background: linear-gradient(180deg, #1b2448, #121a35);
            color: var(--ink);
            border: 1px solid #2a3354;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: transform .05s ease, background .2s ease, border-color .2s ease;
        }

        button:disabled {
            opacity: .6;
            cursor: default;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(180deg, #223064, #121a35);
            border-color: #364170;
        }

        button:active:not(:disabled) {
            transform: translateY(1px);
        }

        .game-shell {
            position: relative;
            border-radius: 14px;
            padding: 10px;
            background: linear-gradient(180deg, #0c2418, #07150e);
            border: 1px solid #173021;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
        }

        canvas {
            display: block;
            width: min(95vw, 940px);
            aspect-ratio: 16 / 10;
            /* 800 x 500 */
            background: #07130d;
            /* jungle canvas base; cleared in JS anyway */
            border-radius: 10px;
        }

        /* Top HUD overlay */
        .hud {
            position: absolute;
            top: 14px;
            left: 14px;
            right: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.28);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            font-family: Arial, Helvetica, sans-serif;
            font-weight: 700;
            color: #eaf6ef;
            text-shadow: 0 1px 0 rgba(0, 0, 0, 0.6);
            user-select: none;
            pointer-events: none;
            /* pass-through */
        }

        .hud .title {
            opacity: 0.96;
        }

        .hud .meta {
            opacity: 0.9;
            font-weight: 700;
        }

        .hud .score {
            min-width: 84px;
            text-align: right;
            font-weight: 700;
        }

        /* Center help/instructions overlay */
        .modal-overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, 0.25);
        }

        .modal-overlay.hidden {
            display: none;
        }

        .overlay-card {
            max-width: 560px;
            width: min(90%, 560px);
            padding: 18px 20px;
            border-radius: 12px;
            background: rgba(8, 20, 14, 0.65);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            color: #eaf6ef;
            text-align: center;
            font-family: Arial, Helvetica, sans-serif;
        }

        .overlay-card h2 {
            margin: 6px 0 8px;
            font-size: 28px;
            font-weight: 700;
        }

        .overlay-card p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.45;
            color: #d7efe2;
        }

        .help {
            display: none;
        }
    </style>
</head>

<body>
    <main class="container">
        <div class="game-shell">
            <canvas id="gameCanvas" width="800" height="500" aria-label="Pong game canvas" role="img"></canvas>
            <div id="hud" class="hud" aria-hidden="true">
                <div class="title">Jungle Pong</div>
                <div class="meta">• Space: Start/Pause • M: Mute • 1: 1P/2P • H: Help</div>
                <div id="scoreHUD" class="score">0 0</div>
            </div>
            <div id="overlay" class="modal-overlay">
                <div class="overlay-card" role="dialog" aria-modal="true" aria-label="Jungle Pong Help">
                    <h2>Jungle Pong</h2>
                    <p><strong>Click</strong> to start. Move your <strong>mouse</strong> to control the left paddle.</p>
                    <p>Press <strong>Space</strong> to Pause/Resume • <strong>M</strong> to Mute • <strong>1</strong> to
                        toggle 1P/2P • <strong>H</strong> for Help</p>
                    <p>First to 7 points wins. Good luck!</p>
                </div>
            </div>
        </div>
    </main>

    <script>
        (function () {
            "use strict";

            // Base logical resolution; canvas is scaled for HiDPI
            const BASE_WIDTH = 800;
            const BASE_HEIGHT = 500;

            // Gameplay constants
            const PADDLE_WIDTH = 12;
            const PADDLE_HEIGHT = 100;
            const PADDLE_SPEED_PX_PER_S = 460;
            const AI_MAX_SPEED_PX_PER_S = 430;
            const BALL_SIZE = 12;
            const BALL_SPEED_START = 360;
            const BALL_SPEED_INCREMENT = 24;
            const BALL_MAX_SPEED = 820;
            const MAX_BOUNCE_ANGLE_RAD = Math.PI * 0.45; // ~81 degrees
            const SERVE_DELAY_MS = 850;
            const WINNING_SCORE = 7;

            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            const hud = document.getElementById("hud");
            const scoreHUD = document.getElementById("scoreHUD");
            const overlay = document.getElementById("overlay");

            // HiDPI crisp rendering
            let devicePixelRatioScale = 1;
            function setupHiDPICanvas() {
                const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
                devicePixelRatioScale = dpr;
                canvas.width = Math.round(BASE_WIDTH * dpr);
                canvas.height = Math.round(BASE_HEIGHT * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.imageSmoothingEnabled = false;
            }

            setupHiDPICanvas();
            window.addEventListener("resize", setupHiDPICanvas);

            // Game state
            const inputState = {
                leftUp: false,
                leftDown: false,
                rightUp: false,
                rightDown: false,
                mouseY: (BASE_HEIGHT - PADDLE_HEIGHT) / 2
            };

            const paddles = {
                left: {
                    x: 28,
                    y: (BASE_HEIGHT - PADDLE_HEIGHT) / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    lastY: 0,
                },
                right: {
                    x: BASE_WIDTH - 28 - PADDLE_WIDTH,
                    y: (BASE_HEIGHT - PADDLE_HEIGHT) / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    lastY: 0,
                },
            };

            const ball = {
                x: (BASE_WIDTH - BALL_SIZE) / 2,
                y: (BASE_HEIGHT - BALL_SIZE) / 2,
                size: BALL_SIZE,
                vx: 0,
                vy: 0,
                speed: BALL_SPEED_START,
            };

            const game = {
                state: "idle", // idle | playing | paused | serving | gameover
                mode: "single", // single | double
                leftScore: 0,
                rightScore: 0,
                lastTimeMs: performance.now(),
                waitUntilMs: 0,
                serveDirection: Math.random() < 0.5 ? -1 : 1, // -1 = to left, 1 = to right
            };

            // Sound
            const sound = {
                muted: false,
                ctx: null,
                ensure() {
                    if (!this.ctx) {
                        const AC = window.AudioContext || window.webkitAudioContext;
                        this.ctx = AC ? new AC() : null;
                    }
                },
                beep(freq = 440, duration = 0.05, type = "sine", gain = 0.03) {
                    if (this.muted) return;
                    this.ensure();
                    if (!this.ctx) return;
                    const t = this.ctx.currentTime;
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.value = freq;
                    g.gain.setValueAtTime(gain, t);
                    g.gain.exponentialRampToValueAtTime(0.0001, t + duration);
                    osc.connect(g).connect(this.ctx.destination);
                    osc.start(t);
                    osc.stop(t + duration + 0.02);
                }
            };

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function resetPositions() {
                paddles.left.y = (BASE_HEIGHT - PADDLE_HEIGHT) / 2;
                paddles.right.y = (BASE_HEIGHT - PADDLE_HEIGHT) / 2;
                paddles.left.lastY = paddles.left.y;
                paddles.right.lastY = paddles.right.y;
                ball.x = (BASE_WIDTH - BALL_SIZE) / 2;
                ball.y = (BASE_HEIGHT - BALL_SIZE) / 2;
                ball.vx = 0;
                ball.vy = 0;
                ball.speed = BALL_SPEED_START;
            }

            function startGame() {
                game.leftScore = 0;
                game.rightScore = 0;
                game.state = "serving";
                game.waitUntilMs = performance.now() + SERVE_DELAY_MS;
                resetPositions();
                overlay.classList.add("hidden");
                hud.setAttribute("aria-hidden", "false");
            }

            function restartGame() { startGame(); }

            function togglePause() {
                if (game.state === "idle" || game.state === "gameover") return;
                if (game.state === "paused") { game.state = "playing"; overlay.classList.add("hidden"); return; }
                if (game.state === "playing" || game.state === "serving") { game.state = "paused"; overlay.classList.remove("hidden"); }
            }

            function toggleMode() {
                if (game.state === "playing") return; // don't allow mid-rally switches
                game.mode = game.mode === "single" ? "double" : "single";
            }

            function serveBall(direction) {
                // direction: -1 = move left, 1 = move right
                ball.x = (BASE_WIDTH - BALL_SIZE) / 2;
                ball.y = (BASE_HEIGHT - BALL_SIZE) / 2;
                ball.speed = BALL_SPEED_START;
                const minAngle = Math.PI * 0.15; // avoid near-horizontal or vertical
                const maxAngle = Math.PI * 0.35;
                const angle = (Math.random() * (maxAngle - minAngle) + minAngle) * (Math.random() < 0.5 ? 1 : -1);
                ball.vx = Math.cos(angle) * ball.speed * direction;
                ball.vy = Math.sin(angle) * ball.speed;
                game.state = "playing";
                overlay.classList.add("hidden");
                sound.beep(360, 0.06, "triangle", 0.03);
            }

            function scheduleServe(nextDirection) {
                game.serveDirection = nextDirection;
                game.state = "serving";
                game.waitUntilMs = performance.now() + SERVE_DELAY_MS;
                resetPositions();
            }

            function pointScored(side) {
                // side: "left" got point or "right" got point
                if (side === "left") game.leftScore += 1; else game.rightScore += 1;
                const someoneWon = game.leftScore >= WINNING_SCORE || game.rightScore >= WINNING_SCORE;
                if (someoneWon) {
                    game.state = "gameover";
                    overlay.classList.remove("hidden");
                    sound.beep(180, 0.18, "sawtooth", 0.05);
                    return;
                }
                const nextDirection = side === "left" ? -1 : 1; // serve towards the player who conceded
                scheduleServe(nextDirection);
                sound.beep(240, 0.1, "square", 0.04);
            }

            function updatePaddleFromInput(paddle, upPressed, downPressed, dtSeconds) {
                let dy = 0;
                if (upPressed) dy -= 1;
                if (downPressed) dy += 1;
                if (dy !== 0) {
                    paddle.y += dy * PADDLE_SPEED_PX_PER_S * dtSeconds;
                }
                paddle.y = clamp(paddle.y, 0, BASE_HEIGHT - paddle.height);
            }

            function updatePaddleFromMouse() {
                const target = clamp(inputState.mouseY - paddles.left.height * 0.5, 0, BASE_HEIGHT - paddles.left.height);
                paddles.left.y = target;
            }

            function updateCpuPaddle(dtSeconds) {
                const paddle = paddles.right;
                const ballCenterY = ball.y + ball.size * 0.5;
                let targetYCenter = ballCenterY;
                // Bias: track harder when ball is moving toward the CPU
                if (ball.vx < 0) {
                    targetYCenter = BASE_HEIGHT * 0.5; // idle near center when ball moving away
                }
                // Slight imperfection
                const baseError = clamp((BALL_MAX_SPEED - ball.speed) * 0.04, 6, 28);
                const missOffset = (Math.random() - 0.5) * baseError;
                targetYCenter += missOffset;

                const targetY = clamp(targetYCenter - paddle.height * 0.5, 0, BASE_HEIGHT - paddle.height);
                const delta = targetY - paddle.y;
                const step = Math.sign(delta) * AI_MAX_SPEED_PX_PER_S * dtSeconds;
                if (Math.abs(step) >= Math.abs(delta)) {
                    paddle.y = targetY;
                } else {
                    paddle.y += step;
                }
            }

            function handleBallWallCollision() {
                // Top/bottom
                if (ball.y <= 0) {
                    ball.y = 0;
                    ball.vy = Math.abs(ball.vy);
                } else if (ball.y + ball.size >= BASE_HEIGHT) {
                    ball.y = BASE_HEIGHT - ball.size;
                    ball.vy = -Math.abs(ball.vy);
                }
            }

            function maybeBounceOffPaddle(paddle, isLeftPaddle) {
                const paddleRight = paddle.x + paddle.width;
                const paddleBottom = paddle.y + paddle.height;
                const ballRight = ball.x + ball.size;
                const ballBottom = ball.y + ball.size;
                const intersects = !(ballRight < paddle.x || ball.x > paddleRight || ballBottom < paddle.y || ball.y > paddleBottom);
                if (!intersects) return false;

                // Place ball just outside paddle to prevent sticking
                if (isLeftPaddle) {
                    ball.x = paddleRight;
                } else {
                    ball.x = paddle.x - ball.size;
                }

                // Compute bounce angle based on contact point
                const paddleCenterY = paddle.y + paddle.height * 0.5;
                const ballCenterY = ball.y + ball.size * 0.5;
                const relativeIntersectY = ballCenterY - paddleCenterY;
                const normalized = clamp(relativeIntersectY / (paddle.height * 0.5), -1, 1);
                const bounceAngle = normalized * MAX_BOUNCE_ANGLE_RAD;

                // Increase speed slightly on each paddle hit
                ball.speed = clamp(ball.speed + BALL_SPEED_INCREMENT, BALL_SPEED_START, BALL_MAX_SPEED);
                const direction = isLeftPaddle ? 1 : -1;
                ball.vx = Math.cos(bounceAngle) * ball.speed * direction;
                ball.vy = Math.sin(bounceAngle) * ball.speed;
                sound.beep(520, 0.04, "square", 0.035);
                return true;
            }

            function update(dtSeconds) {
                if (game.state === "paused" || game.state === "idle" || game.state === "gameover") return;

                if (game.state === "serving") {
                    if (performance.now() >= game.waitUntilMs) {
                        serveBall(game.serveDirection);
                    }
                    return;
                }

                // Paddles
                // Left paddle: mouse-controlled
                updatePaddleFromMouse();
                if (game.mode === "double") {
                    updatePaddleFromInput(paddles.right, inputState.rightUp, inputState.rightDown, dtSeconds);
                } else {
                    updateCpuPaddle(dtSeconds);
                }

                // Ball movement
                ball.x += ball.vx * dtSeconds;
                ball.y += ball.vy * dtSeconds;

                // Wall collisions
                handleBallWallCollision();

                // Paddle collisions
                if (ball.vx < 0) {
                    maybeBounceOffPaddle(paddles.left, true);
                } else if (ball.vx > 0) {
                    maybeBounceOffPaddle(paddles.right, false);
                }

                // Scoring
                if (ball.x + ball.size < 0) {
                    pointScored("right");
                } else if (ball.x > BASE_WIDTH) {
                    pointScored("left");
                }
            }

            function drawNet() {
                ctx.fillStyle = "#163624";
                const dashHeight = 14;
                const gap = 12;
                const x = (BASE_WIDTH - 4) / 2;
                for (let y = 0; y < BASE_HEIGHT; y += dashHeight + gap) {
                    ctx.fillRect(x, y, 4, dashHeight);
                }
            }

            function updateHud() {
                if (scoreHUD) scoreHUD.textContent = `${game.leftScore} ${game.rightScore}`;
            }

            function drawPaddle(p) {
                // Bark base
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--paddle-bark").trim() || "#6d4b2d";
                ctx.fillRect(p.x, p.y, p.width, p.height);
                // Green diagonal stripes
                const stripeColor = getComputedStyle(document.documentElement).getPropertyValue("--paddle-stripe").trim() || "#2fb36b";
                ctx.fillStyle = stripeColor;
                const stripeWidth = 3;
                const spacing = 8;
                ctx.save();
                ctx.beginPath();
                ctx.rect(p.x, p.y, p.width, p.height);
                ctx.clip();
                for (let i = -p.height; i < p.height + p.width; i += spacing) {
                    ctx.fillRect(p.x - p.height + i, p.y + i, stripeWidth, p.height);
                }
                ctx.restore();
            }

            function drawBall() {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--ball").trim() || "#ffffff";
                ctx.fillRect(ball.x, ball.y, ball.size, ball.size);
            }

            // Jungle background with floating leaves
            const leaves = [];
            function makeLeaf() {
                const types = [0, 1, 2];
                const type = types[Math.floor(Math.random() * types.length)];
                const scale = Math.random() * 0.6 + 0.6; // 0.6 - 1.2
                return {
                    x: Math.random() * BASE_WIDTH,
                    y: Math.random() * BASE_HEIGHT,
                    vy: Math.random() * 16 + 10, // fall speed
                    driftAmp: Math.random() * 20 + 10,
                    driftFreq: Math.random() * 0.8 + 0.6,
                    phase: Math.random() * Math.PI * 2,
                    rot: Math.random() * Math.PI * 2,
                    spin: (Math.random() - 0.5) * 0.6,
                    type,
                    scale,
                    color: Math.random() < 0.5 ? "#2ba164" : "#1f8b4f"
                };
            }

            function initLeaves(count = 36) {
                leaves.length = 0;
                for (let i = 0; i < count; i++) leaves.push(makeLeaf());
            }

            function updateLeaves(dt) {
                for (const lf of leaves) {
                    lf.y += lf.vy * dt;
                    lf.x += Math.sin(lf.y * 0.02 * lf.driftFreq + lf.phase) * 8 * dt * 60;
                    lf.rot += lf.spin * dt;
                    if (lf.y > BASE_HEIGHT + 20) {
                        lf.y = -20;
                        lf.x = Math.random() * BASE_WIDTH;
                        lf.vy = Math.random() * 16 + 10;
                        lf.phase = Math.random() * Math.PI * 2;
                    }
                }
            }

            function drawLeafShape(type) {
                switch (type) {
                    case 0: {
                        // ellipse
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 9, 16, 0, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }
                    case 1: {
                        // teardrop/bezier leaf
                        ctx.beginPath();
                        ctx.moveTo(0, -18);
                        ctx.bezierCurveTo(10, -10, 10, 10, 0, 18);
                        ctx.bezierCurveTo(-10, 10, -10, -10, 0, -18);
                        ctx.fill();
                        break;
                    }
                    case 2: {
                        // long thin leaf
                        ctx.beginPath();
                        ctx.moveTo(0, -20);
                        ctx.quadraticCurveTo(8, -6, 6, 0);
                        ctx.quadraticCurveTo(4, 10, 0, 20);
                        ctx.quadraticCurveTo(-4, 10, -6, 0);
                        ctx.quadraticCurveTo(-8, -6, 0, -20);
                        ctx.fill();
                        break;
                    }
                }
            }

            function drawLeaves() {
                for (const lf of leaves) {
                    ctx.save();
                    ctx.translate(lf.x, lf.y);
                    ctx.rotate(lf.rot);
                    ctx.scale(lf.scale, lf.scale);
                    ctx.fillStyle = lf.color;
                    drawLeafShape(lf.type);
                    ctx.restore();
                }
            }

            function drawBackground() {
                const gradient = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
                gradient.addColorStop(0, "#0b2418");
                gradient.addColorStop(1, "#08170f");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                drawLeaves();
            }

            function draw() {
                drawBackground();
                drawNet();
                drawPaddle(paddles.left);
                drawPaddle(paddles.right);
                drawBall();
                // HUD DOM handles instructions/overlay; canvas stays clean
            }

            function frame(nowMs) {
                const dtSeconds = Math.min(0.033, (nowMs - game.lastTimeMs) / 1000);
                game.lastTimeMs = nowMs;
                updateLeaves(dtSeconds);
                update(dtSeconds);
                draw();
                updateHud();
                requestAnimationFrame(frame);
            }

            // Input handling
            function handleKey(e, isDown) {
                switch (e.code) {
                    // Left paddle is mouse-controlled
                    case "ArrowUp": inputState.rightUp = isDown; break;
                    case "ArrowDown": inputState.rightDown = isDown; break;
                    case "Space": if (isDown) { e.preventDefault(); if (game.state === "idle") { startGame(); } else { togglePause(); } } break;
                    case "KeyR": if (isDown) { restartGame(); } break;
                    case "KeyM": if (isDown) { sound.muted = !sound.muted; } break;
                    case "Digit1": if (isDown) { toggleMode(); } break;
                    case "KeyH": if (isDown) { if (overlay.classList.contains("hidden")) { overlay.classList.remove("hidden"); game.state === "playing" && (game.state = "paused"); } else { overlay.classList.add("hidden"); } } break;
                    case "Enter": if (isDown) {
                        if (game.state === "idle" || game.state === "gameover") {
                            startGame();
                        } else if (game.state === "serving") {
                            serveBall(game.serveDirection);
                        }
                    } break;
                }
            }

            document.addEventListener("keydown", (e) => handleKey(e, true));
            document.addEventListener("keyup", (e) => handleKey(e, false));

            // Mouse control + click to start
            canvas.addEventListener("mousemove", (e) => {
                const rect = canvas.getBoundingClientRect();
                const y = (e.clientY - rect.top) * (BASE_HEIGHT / rect.height);
                inputState.mouseY = y;
            });

            canvas.addEventListener("click", () => {
                if (game.state === "idle" || game.state === "gameover") {
                    startGame();
                } else if (game.state === "serving") {
                    serveBall(game.serveDirection);
                } else if (game.state === "paused") {
                    togglePause();
                }
            });

            // Also allow clicking the overlay to start/close
            overlay.addEventListener("click", () => {
                if (game.state === "idle" || game.state === "gameover") startGame();
                else if (game.state === "paused") togglePause();
            });

            // Prevent page scroll on arrow keys when focused on body
            window.addEventListener("keydown", (e) => {
                if (["ArrowUp", "ArrowDown", "Space"].includes(e.code)) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Start loop
            initLeaves();
            requestAnimationFrame((t) => { game.lastTimeMs = t; requestAnimationFrame(frame); });
        })();
    </script>
</body>

</html>