<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pong</title>
    <style>
        :root {
            --bg: #0b1020;
            --panel: #0f1530;
            --ink: #e8ecf6;
            --muted: #9aa3b2;
            --line: #273047;
            --accent: #6de3b2;
            --ball: #ffffff;
            --paddle: #f6f7fb;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            margin: 0;
            background: radial-gradient(1200px 700px at 50% -10%, #162142 0%, var(--bg) 60%);
            color: var(--ink);
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            display: grid;
            place-items: center;
        }

        .container {
            width: min(95vw, 960px);
            padding: 16px;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 12px;
        }

        button {
            background: linear-gradient(180deg, #1b2448, #121a35);
            color: var(--ink);
            border: 1px solid #2a3354;
            border-radius: 10px;
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            transition: transform .05s ease, background .2s ease, border-color .2s ease;
        }

        button:disabled {
            opacity: .6;
            cursor: default;
        }

        button:hover:not(:disabled) {
            background: linear-gradient(180deg, #223064, #121a35);
            border-color: #364170;
        }

        button:active:not(:disabled) {
            transform: translateY(1px);
        }

        .game-shell {
            position: relative;
            border-radius: 14px;
            padding: 10px;
            background: linear-gradient(180deg, #11172f, #0b1127);
            border: 1px solid #1d2544;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
        }

        canvas {
            display: block;
            width: min(95vw, 940px);
            aspect-ratio: 16 / 10;
            /* 800 x 500 */
            background: #0b0f1f;
            /* cleared in JS anyway */
            border-radius: 10px;
        }

        .help {
            text-align: center;
            margin-top: 10px;
            color: var(--muted);
            font-size: 14px;
            user-select: none;
        }
    </style>
</head>

<body>
    <main class="container">
        <div class="controls">
            <button id="modeButton" type="button" aria-pressed="false">Mode: 1 Player</button>
            <button id="startButton" type="button">Start</button>
            <button id="pauseButton" type="button" disabled>Pause</button>
            <button id="restartButton" type="button">Restart</button>
        </div>
        <div class="game-shell">
            <canvas id="gameCanvas" width="800" height="500" aria-label="Pong game canvas" role="img"></canvas>
        </div>
        <div class="help">W/S or ↑/↓ to move • Space to pause • R to restart • M toggles 1P/2P</div>
    </main>

    <script>
        (function () {
            "use strict";

            // Base logical resolution; canvas is scaled for HiDPI
            const BASE_WIDTH = 800;
            const BASE_HEIGHT = 500;

            // Gameplay constants
            const PADDLE_WIDTH = 12;
            const PADDLE_HEIGHT = 100;
            const PADDLE_SPEED_PX_PER_S = 460;
            const AI_MAX_SPEED_PX_PER_S = 430;
            const BALL_SIZE = 12;
            const BALL_SPEED_START = 360;
            const BALL_SPEED_INCREMENT = 24;
            const BALL_MAX_SPEED = 820;
            const MAX_BOUNCE_ANGLE_RAD = Math.PI * 0.45; // ~81 degrees
            const SERVE_DELAY_MS = 850;
            const WINNING_SCORE = 7;

            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");

            // HiDPI crisp rendering
            let devicePixelRatioScale = 1;
            function setupHiDPICanvas() {
                const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
                devicePixelRatioScale = dpr;
                canvas.width = Math.round(BASE_WIDTH * dpr);
                canvas.height = Math.round(BASE_HEIGHT * dpr);
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                ctx.imageSmoothingEnabled = false;
            }

            setupHiDPICanvas();
            window.addEventListener("resize", setupHiDPICanvas);

            // Game state
            const inputState = {
                leftUp: false,
                leftDown: false,
                rightUp: false,
                rightDown: false,
            };

            const paddles = {
                left: {
                    x: 28,
                    y: (BASE_HEIGHT - PADDLE_HEIGHT) / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    lastY: 0,
                },
                right: {
                    x: BASE_WIDTH - 28 - PADDLE_WIDTH,
                    y: (BASE_HEIGHT - PADDLE_HEIGHT) / 2,
                    width: PADDLE_WIDTH,
                    height: PADDLE_HEIGHT,
                    lastY: 0,
                },
            };

            const ball = {
                x: (BASE_WIDTH - BALL_SIZE) / 2,
                y: (BASE_HEIGHT - BALL_SIZE) / 2,
                size: BALL_SIZE,
                vx: 0,
                vy: 0,
                speed: BALL_SPEED_START,
            };

            const game = {
                state: "idle", // idle | playing | paused | serving | gameover
                mode: "single", // single | double
                leftScore: 0,
                rightScore: 0,
                lastTimeMs: performance.now(),
                waitUntilMs: 0,
                serveDirection: Math.random() < 0.5 ? -1 : 1, // -1 = to left, 1 = to right
            };

            // UI elements
            const startButton = document.getElementById("startButton");
            const pauseButton = document.getElementById("pauseButton");
            const restartButton = document.getElementById("restartButton");
            const modeButton = document.getElementById("modeButton");

            function clamp(value, min, max) {
                return Math.max(min, Math.min(max, value));
            }

            function resetPositions() {
                paddles.left.y = (BASE_HEIGHT - PADDLE_HEIGHT) / 2;
                paddles.right.y = (BASE_HEIGHT - PADDLE_HEIGHT) / 2;
                paddles.left.lastY = paddles.left.y;
                paddles.right.lastY = paddles.right.y;
                ball.x = (BASE_WIDTH - BALL_SIZE) / 2;
                ball.y = (BASE_HEIGHT - BALL_SIZE) / 2;
                ball.vx = 0;
                ball.vy = 0;
                ball.speed = BALL_SPEED_START;
            }

            function startGame() {
                game.leftScore = 0;
                game.rightScore = 0;
                game.state = "serving";
                game.waitUntilMs = performance.now() + SERVE_DELAY_MS;
                resetPositions();
                startButton.disabled = true;
                pauseButton.disabled = false;
            }

            function restartGame() {
                startGame();
            }

            function togglePause() {
                if (game.state === "idle" || game.state === "gameover") return;
                if (game.state === "paused") {
                    game.state = "playing";
                    pauseButton.textContent = "Pause";
                    return;
                }
                if (game.state === "playing" || game.state === "serving") {
                    game.state = "paused";
                    pauseButton.textContent = "Resume";
                }
            }

            function toggleMode() {
                if (game.state === "playing") return; // don't allow mid-rally switches
                game.mode = game.mode === "single" ? "double" : "single";
                modeButton.textContent = `Mode: ${game.mode === "single" ? "1 Player" : "2 Players"}`;
                modeButton.setAttribute("aria-pressed", String(game.mode === "double"));
            }

            function serveBall(direction) {
                // direction: -1 = move left, 1 = move right
                ball.x = (BASE_WIDTH - BALL_SIZE) / 2;
                ball.y = (BASE_HEIGHT - BALL_SIZE) / 2;
                ball.speed = BALL_SPEED_START;
                const minAngle = Math.PI * 0.15; // avoid near-horizontal or vertical
                const maxAngle = Math.PI * 0.35;
                const angle = (Math.random() * (maxAngle - minAngle) + minAngle) * (Math.random() < 0.5 ? 1 : -1);
                ball.vx = Math.cos(angle) * ball.speed * direction;
                ball.vy = Math.sin(angle) * ball.speed;
                game.state = "playing";
                pauseButton.textContent = "Pause";
            }

            function scheduleServe(nextDirection) {
                game.serveDirection = nextDirection;
                game.state = "serving";
                game.waitUntilMs = performance.now() + SERVE_DELAY_MS;
                resetPositions();
            }

            function pointScored(side) {
                // side: "left" got point or "right" got point
                if (side === "left") game.leftScore += 1; else game.rightScore += 1;
                const someoneWon = game.leftScore >= WINNING_SCORE || game.rightScore >= WINNING_SCORE;
                if (someoneWon) {
                    game.state = "gameover";
                    startButton.disabled = false;
                    pauseButton.disabled = true;
                    return;
                }
                const nextDirection = side === "left" ? -1 : 1; // serve towards the player who conceded
                scheduleServe(nextDirection);
            }

            function updatePaddleFromInput(paddle, upPressed, downPressed, dtSeconds) {
                let dy = 0;
                if (upPressed) dy -= 1;
                if (downPressed) dy += 1;
                if (dy !== 0) {
                    paddle.y += dy * PADDLE_SPEED_PX_PER_S * dtSeconds;
                }
                paddle.y = clamp(paddle.y, 0, BASE_HEIGHT - paddle.height);
            }

            function updateCpuPaddle(dtSeconds) {
                const paddle = paddles.right;
                const ballCenterY = ball.y + ball.size * 0.5;
                let targetYCenter = ballCenterY;
                // Bias: track harder when ball is moving toward the CPU
                if (ball.vx < 0) {
                    targetYCenter = BASE_HEIGHT * 0.5; // idle near center when ball moving away
                }
                // Slight imperfection
                const baseError = clamp((BALL_MAX_SPEED - ball.speed) * 0.04, 6, 28);
                const missOffset = (Math.random() - 0.5) * baseError;
                targetYCenter += missOffset;

                const targetY = clamp(targetYCenter - paddle.height * 0.5, 0, BASE_HEIGHT - paddle.height);
                const delta = targetY - paddle.y;
                const step = Math.sign(delta) * AI_MAX_SPEED_PX_PER_S * dtSeconds;
                if (Math.abs(step) >= Math.abs(delta)) {
                    paddle.y = targetY;
                } else {
                    paddle.y += step;
                }
            }

            function handleBallWallCollision() {
                // Top/bottom
                if (ball.y <= 0) {
                    ball.y = 0;
                    ball.vy = Math.abs(ball.vy);
                } else if (ball.y + ball.size >= BASE_HEIGHT) {
                    ball.y = BASE_HEIGHT - ball.size;
                    ball.vy = -Math.abs(ball.vy);
                }
            }

            function maybeBounceOffPaddle(paddle, isLeftPaddle) {
                const paddleRight = paddle.x + paddle.width;
                const paddleBottom = paddle.y + paddle.height;
                const ballRight = ball.x + ball.size;
                const ballBottom = ball.y + ball.size;
                const intersects = !(ballRight < paddle.x || ball.x > paddleRight || ballBottom < paddle.y || ball.y > paddleBottom);
                if (!intersects) return false;

                // Place ball just outside paddle to prevent sticking
                if (isLeftPaddle) {
                    ball.x = paddleRight;
                } else {
                    ball.x = paddle.x - ball.size;
                }

                // Compute bounce angle based on contact point
                const paddleCenterY = paddle.y + paddle.height * 0.5;
                const ballCenterY = ball.y + ball.size * 0.5;
                const relativeIntersectY = ballCenterY - paddleCenterY;
                const normalized = clamp(relativeIntersectY / (paddle.height * 0.5), -1, 1);
                const bounceAngle = normalized * MAX_BOUNCE_ANGLE_RAD;

                // Increase speed slightly on each paddle hit
                ball.speed = clamp(ball.speed + BALL_SPEED_INCREMENT, BALL_SPEED_START, BALL_MAX_SPEED);
                const direction = isLeftPaddle ? 1 : -1;
                ball.vx = Math.cos(bounceAngle) * ball.speed * direction;
                ball.vy = Math.sin(bounceAngle) * ball.speed;
                return true;
            }

            function update(dtSeconds) {
                if (game.state === "paused" || game.state === "idle" || game.state === "gameover") return;

                if (game.state === "serving") {
                    if (performance.now() >= game.waitUntilMs) {
                        serveBall(game.serveDirection);
                    }
                    return;
                }

                // Paddles
                updatePaddleFromInput(paddles.left, inputState.leftUp, inputState.leftDown, dtSeconds);
                if (game.mode === "double") {
                    updatePaddleFromInput(paddles.right, inputState.rightUp, inputState.rightDown, dtSeconds);
                } else {
                    updateCpuPaddle(dtSeconds);
                }

                // Ball movement
                ball.x += ball.vx * dtSeconds;
                ball.y += ball.vy * dtSeconds;

                // Wall collisions
                handleBallWallCollision();

                // Paddle collisions
                if (ball.vx < 0) {
                    maybeBounceOffPaddle(paddles.left, true);
                } else if (ball.vx > 0) {
                    maybeBounceOffPaddle(paddles.right, false);
                }

                // Scoring
                if (ball.x + ball.size < 0) {
                    pointScored("right");
                } else if (ball.x > BASE_WIDTH) {
                    pointScored("left");
                }
            }

            function drawNet() {
                ctx.fillStyle = "#243050";
                const dashHeight = 14;
                const gap = 12;
                const x = (BASE_WIDTH - 4) / 2;
                for (let y = 0; y < BASE_HEIGHT; y += dashHeight + gap) {
                    ctx.fillRect(x, y, 4, dashHeight);
                }
            }

            function drawScores() {
                ctx.fillStyle = "#cfd6ea";
                ctx.font = "bold 48px ui-sans-serif, system-ui, -apple-system, Segoe UI";
                ctx.textAlign = "center";
                ctx.textBaseline = "top";
                ctx.fillText(String(game.leftScore), BASE_WIDTH * 0.5 - 80, 18);
                ctx.fillText(String(game.rightScore), BASE_WIDTH * 0.5 + 80, 18);
                ctx.font = "bold 14px ui-sans-serif, system-ui, -apple-system";
                ctx.fillStyle = "#8592b3";
                ctx.fillText(game.mode === "single" ? "1P vs CPU" : "2P", BASE_WIDTH * 0.5, 74);
            }

            function drawPaddle(p) {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--paddle").trim() || "#ffffff";
                ctx.fillRect(p.x, p.y, p.width, p.height);
            }

            function drawBall() {
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue("--ball").trim() || "#ffffff";
                ctx.fillRect(ball.x, ball.y, ball.size, ball.size);
            }

            function drawOverlay(text, subText) {
                ctx.save();
                ctx.fillStyle = "rgba(4,8,20,.66)";
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
                ctx.fillStyle = "#e8ecf6";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.font = "bold 36px ui-sans-serif, system-ui, -apple-system";
                ctx.fillText(text, BASE_WIDTH / 2, BASE_HEIGHT / 2 - 10);
                if (subText) {
                    ctx.fillStyle = "#a9b2c9";
                    ctx.font = "16px ui-sans-serif, system-ui, -apple-system";
                    ctx.fillText(subText, BASE_WIDTH / 2, BASE_HEIGHT / 2 + 28);
                }
                ctx.restore();
            }

            function drawBackground() {
                const gradient = ctx.createLinearGradient(0, 0, 0, BASE_HEIGHT);
                gradient.addColorStop(0, "#0b0f1f");
                gradient.addColorStop(1, "#0a0d1a");
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, BASE_WIDTH, BASE_HEIGHT);
            }

            function draw() {
                drawBackground();
                drawNet();
                drawScores();
                drawPaddle(paddles.left);
                drawPaddle(paddles.right);
                drawBall();

                if (game.state === "idle") {
                    drawOverlay("Pong", "Press Enter or Start to play");
                } else if (game.state === "paused") {
                    drawOverlay("Paused", "Press Space or Resume to continue");
                } else if (game.state === "serving") {
                    drawOverlay("Get Ready", "Serving in a moment...");
                } else if (game.state === "gameover") {
                    const winner = game.leftScore > game.rightScore ? "Left Player" : (game.mode === "single" ? "CPU" : "Right Player");
                    drawOverlay(`${winner} Wins!`, "Press Start or R to play again");
                }
            }

            function frame(nowMs) {
                const dtSeconds = Math.min(0.033, (nowMs - game.lastTimeMs) / 1000);
                game.lastTimeMs = nowMs;
                update(dtSeconds);
                draw();
                requestAnimationFrame(frame);
            }

            // Input handling
            function handleKey(e, isDown) {
                switch (e.code) {
                    case "KeyW": inputState.leftUp = isDown; break;
                    case "KeyS": inputState.leftDown = isDown; break;
                    case "ArrowUp": inputState.rightUp = isDown; break;
                    case "ArrowDown": inputState.rightDown = isDown; break;
                    case "Space": if (isDown) { e.preventDefault(); togglePause(); } break;
                    case "KeyR": if (isDown) { restartGame(); } break;
                    case "KeyM": if (isDown) { toggleMode(); } break;
                    case "Enter": if (isDown) {
                        if (game.state === "idle" || game.state === "gameover") {
                            startGame();
                        } else if (game.state === "serving") {
                            serveBall(game.serveDirection);
                        }
                    } break;
                }
            }

            document.addEventListener("keydown", (e) => handleKey(e, true));
            document.addEventListener("keyup", (e) => handleKey(e, false));

            // Mouse/touch to serve when waiting
            canvas.addEventListener("click", () => {
                if (game.state === "idle" || game.state === "gameover") {
                    startGame();
                } else if (game.state === "serving") {
                    serveBall(game.serveDirection);
                }
            });

            // Buttons
            startButton.addEventListener("click", startGame);
            restartButton.addEventListener("click", restartGame);
            pauseButton.addEventListener("click", togglePause);
            modeButton.addEventListener("click", toggleMode);

            // Prevent page scroll on arrow keys when focused on body
            window.addEventListener("keydown", (e) => {
                if (["ArrowUp", "ArrowDown", "Space"].includes(e.code)) {
                    e.preventDefault();
                }
            }, { passive: false });

            // Start loop
            requestAnimationFrame((t) => { game.lastTimeMs = t; requestAnimationFrame(frame); });

            // Initial UI state
            modeButton.textContent = `Mode: ${game.mode === "single" ? "1 Player" : "2 Players"}`;
            pauseButton.textContent = "Pause";
        })();
    </script>
</body>

</html>