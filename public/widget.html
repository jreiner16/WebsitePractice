<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Rhythm Practice</title>
    <meta name="theme-color" content="#0f172a" />
    <style>
        :root {
            --bg: #0f172a;
            --panel: #111827;
            --panel-border: #1f2937;
            --text: #e5e7eb;
            --muted: #9ca3af;
            --accent: #60a5fa;
            --good: #22c55e;
            --bad: #ef4444;
            --warn: #f59e0b;
        }

        * {
            box-sizing: border-box;
        }

        html,
        body {
            margin: 0;
            height: 100%;
            background: radial-gradient(900px 520px at 20% 20%, #0b1220, #0f172a 60%),
                radial-gradient(700px 420px at 80% 0%, #0b1324, transparent 60%),
                radial-gradient(900px 520px at 80% 100%, #0a1326, transparent 60%);
            color: var(--text);
            font-family: ui-monospace, Menlo, Monaco, 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            overflow: hidden;
        }

        .container {
            position: fixed;
            inset: 0;
            display: grid;
            grid-template-columns: 1fr;
            gap: 0;
        }

        .container.no-sidebar {
            grid-template-columns: 1fr;
        }

        .container.no-sidebar .sidebar {
            display: none;
        }

        .sidebar {
            display: none;
        }

        .main-content {
            padding: 20px;
            overflow: hidden;
        }

        .card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text);
        }

        .subtitle {
            font-size: 13px;
            color: var(--muted);
            margin-bottom: 12px;
        }

        .row {
            display: grid;
            grid-template-columns: 1fr 80px;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-label {
            display: block;
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 6px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        select,
        input[type="number"],
        input[type="text"],
        input[type="range"] {
            width: 100%;
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            padding: 8px 10px;
            color: var(--text);
            font-size: 14px;
        }

        input[type="range"] {
            height: 30px;
            padding: 0;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.2);
        }

        .switch {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }

        .switch input {
            margin: 0;
        }

        button {
            background: rgba(255, 255, 255, 0.04);
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 8px;
            padding: 8px 14px;
            color: var(--text);
            cursor: pointer;
            font-size: 14px;
            transition: background 0.12s ease, border-color 0.12s ease, transform 0.05s ease;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: var(--accent);
        }

        button.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: #0b1220;
            font-weight: 600;
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Pill selectors */
        .pill-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .pill {
            display: inline;
            padding: 0;
            color: var(--muted);
            font-size: 14px;
            cursor: pointer;
            transition: color 0.12s ease;
            user-select: none;
        }

        .pill+.pill::before {
            content: " / ";
            color: rgba(255, 255, 255, 0.18);
            margin: 0 4px;
        }

        .pill:hover {
            color: var(--text);
        }

        .pill.active {
            color: var(--accent);
            font-weight: 700;
        }

        /* Range slider (BPM) */
        .range-wrap {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            font-size: 14px;
            color: var(--text);
            min-width: 44px;
            text-align: right;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.08);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent);
            border: 1px solid rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border: none;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
        }

        .actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .stat {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .stat .label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat .value {
            font-size: 18px;
            font-weight: 700;
            margin-top: 4px;
        }

        .legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            font-size: 12px;
            color: var(--muted);
        }

        .legend .dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .meter {
            height: 6px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            overflow: hidden;
        }

        .meter .fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.1s linear;
        }

        .canvas-wrap {
            position: relative;
            border-radius: 10px;
            overflow-x: hidden;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.02);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.035), rgba(255, 255, 255, 0.015));
        }

        .start-overlay {
            position: absolute;
            inset: 0;
            display: none;
            background: transparent;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            backdrop-filter: blur(36px);
            -webkit-backdrop-filter: blur(36px);
            display: grid;
            grid-template-rows: auto 1fr;
            align-content: start;
            justify-items: center;
            padding-top: 12px;
        }

        .start-content {
            width: 100%;
            text-align: center;
        }

        .big-start {
            background: var(--accent);
            border: 1px solid var(--accent);
            color: #0b1220;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 0.3px;
            padding: 12px 22px;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.05s ease, box-shadow 0.15s ease;
            box-shadow: 0 8px 24px rgba(96, 165, 250, 0.35);
        }

        .big-start:hover {
            transform: translateY(-1px);
            box-shadow: 0 12px 28px rgba(96, 165, 250, 0.45);
        }

        .hint {
            margin-top: 8px;
            font-size: 12px;
            color: var(--muted);
        }

        .start-bar {
            display: flex;
            align-items: center;
            gap: 24px;
            padding: 12px 18px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            justify-content: space-between;
            flex-wrap: nowrap;
        }

        .sb-left,
        .sb-right {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 18px;
            flex-wrap: nowrap;
        }

        /* Even internal spacing with symmetric padding and separators */
        .sb-left>div,
        .sb-right>div {
            position: relative;
            padding: 0 14px;
        }

        .sb-left>div:first-child,
        .sb-right>div:first-child {
            padding-left: 0;
        }

        .sb-left>div:last-child,
        .sb-right>div:last-child {
            padding-right: 0;
        }

        .sb-left>div+div::before,
        .sb-right>div+div::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 1px;
            height: 22px;
            background: rgba(255, 255, 255, 0.16);
        }

        /* Center bar divider */
        .bar-sep {
            width: 1px;
            height: 24px;
            background: rgba(255, 255, 255, 0.16);
            margin: 0 14px;
        }

        .start-title {
            display: none;
        }

        .start-hint {
            font-size: 18px;
            color: var(--muted);
            cursor: pointer;
            user-select: none;
        }

        /* Absolute center hint overlay, independent of top bar */
        .start-hint-wrap {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            /* allow clicks on child only */
        }

        .start-hint-wrap .start-hint {
            pointer-events: auto;
        }

        .pill-group {
            white-space: nowrap;
        }

        .summary-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: transparent;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            backdrop-filter: blur(36px);
            -webkit-backdrop-filter: blur(36px);
        }

        .summary-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.10);
            border-radius: 12px;
            padding: 16px;
            width: min(680px, 92%);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-top: 12px;
        }

        .summary-stat {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
        }

        .summary-actions {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
            margin-top: 12px;
        }

        .countin-overlay {
            position: absolute;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .countin-number {
            font-family: ui-monospace, Menlo, Monaco, 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
            font-weight: 700;
            font-size: 56px;
            color: rgba(229, 231, 235, 0.95);
            text-shadow: 0 6px 24px rgba(0, 0, 0, 0.5);
        }



        .feedback {
            margin-top: 8px;
            font-size: 13px;
            min-height: 18px;
        }

        .feedback .good {
            color: var(--good);
        }

        .feedback .bad {
            color: var(--bad);
        }

        .feedback .warn {
            color: var(--warn);
        }

        @media (max-width: 900px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }

            .sidebar {
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.06);
            }
        }

        /* Mobile adjustments */
        @media (max-width: 640px) {
            .start-bar {
                flex-wrap: wrap;
                gap: 10px;
                justify-content: center;
            }

            .sb-left,
            .sb-right {
                flex-wrap: wrap;
                gap: 10px;
            }

            .sb-left>div,
            .sb-right>div {
                padding: 0 8px;
            }

            .sb-left>div+div::before,
            .sb-right>div+div::before {
                display: none;
            }

            .bar-sep {
                display: none;
            }
        }

        /* uPlot dark theme adjustments */
        .uplot {
            font-family: ui-monospace, Menlo, Monaco, 'SFMono-Regular', Consolas, 'Liberation Mono', monospace;
        }

        .uplot .u-legend {
            display: none;
        }

        .uplot .u-axis {
            color: var(--muted);
        }

        .uplot .u-grid {
            stroke: rgba(255, 255, 255, 0.08);
        }

        .uplot .u-select {
            background: rgba(96, 165, 250, 0.08);
            border: 1px solid rgba(96, 165, 250, 0.3);
        }
    </style>
    <link rel="stylesheet" href="https://unpkg.com/uplot@1.6.28/dist/uPlot.min.css" />
    <script defer src="https://unpkg.com/uplot@1.6.28/dist/uPlot.iife.min.js"></script>
</head>

<body>
    <div class="container">
        <div class="sidebar">
            <div class="card">
                <div class="title">Performance</div>
                <div class="stats">
                    <div class="stat">
                        <div class="label">Accuracy</div>
                        <div class="value" id="stat-acc">0%</div>
                    </div>
                    <div class="stat">
                        <div class="label">Hits</div>
                        <div class="value" id="stat-hits">0</div>
                    </div>
                    <div class="stat">
                        <div class="label">Misses</div>
                        <div class="value" id="stat-miss">0</div>
                    </div>
                    <div class="stat">
                        <div class="label">Combo</div>
                        <div class="value" id="stat-combo">0</div>
                    </div>
                </div>
                <div class="subtitle" style="margin-top:10px;">Timing feedback</div>
                <div class="feedback" id="timingFeedback"></div>
                <div class="subtitle" style="margin-top:10px;">Progress</div>
                <div class="meter">
                    <div class="fill" id="progressFill"></div>
                </div>
                <div class="subtitle" style="margin-top:10px;">Legend</div>
                <div class="legend">
                    <div><span class="dot" style="background:var(--text)"></span> Pending</div>
                    <div><span class="dot" style="background:var(--good)"></span> Good</div>
                    <div><span class="dot" style="background:var(--bad)"></span> Miss</div>
                    <div><span class="dot" style="background:var(--warn)"></span> Early/Late</div>
                </div>
                <div class="actions" style="margin-top:10px;">
                    <button id="stop">Stop</button>
                    <button id="reset">Reset Score</button>
                </div>
            </div>
        </div>

        <div class="main-content">
            <div class="card">
                <div class="title">Rhythm Reading</div>
                <div class="subtitle">Practice sight-reading rhythms</div>
                <div class="canvas-wrap">
                    <canvas id="sheet"></canvas>
                    <div class="start-overlay" id="startOverlay">
                        <div class="start-content">
                            <div class="start-bar">
                                <div class="sb-left">
                                    <div>
                                        <label class="control-label" for="bpm">BPM</label>
                                        <div class="range-wrap">
                                            <input id="bpm" type="range" min="30" max="240" step="1" value="100" />
                                            <div class="range-value"><span id="bpmVal">100</span></div>
                                        </div>
                                    </div>
                                    <div>
                                        <label class="control-label" for="measures">Measures</label>
                                        <input id="measures" type="number" min="1" max="32" step="1" value="4"
                                            style="display:none;" />
                                        <div id="measuresGroup" class="pill-group"></div>
                                    </div>
                                </div>
                                <div class="bar-sep"></div>
                                <div class="sb-right">
                                    <div>
                                        <label class="control-label" for="timeSig">Time Signature</label>
                                        <select id="timeSig" style="display:none;">
                                            <option value="4/4">4/4</option>
                                            <option value="3/4">3/4</option>
                                            <option value="2/4">2/4</option>
                                            <option value="6/8">6/8</option>
                                        </select>
                                        <div id="timeSigGroup" class="pill-group"></div>
                                    </div>
                                    <div>
                                        <label class="control-label" for="difficulty">Difficulty</label>
                                        <select id="difficulty" style="display:none;">
                                            <option value="easy">Easy</option>
                                            <option value="medium">Medium</option>
                                            <option value="hard">Hard</option>
                                        </select>
                                        <div id="difficultyGroup" class="pill-group"></div>
                                    </div>
                                    <div>
                                        <label class="switch">
                                            <input id="metronome" type="checkbox" checked />
                                            <span>Metronome</span>
                                        </label>
                                        <label class="switch" style="margin-left:10px;">
                                            <input id="countIn" type="checkbox" checked />
                                            <span>Count-in</span>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="start-hint-wrap">
                            <div id="startHint" class="start-hint">press space or tap to start</div>
                        </div>
                    </div>
                    <div class="summary-overlay" id="summaryOverlay">
                        <div class="summary-card">
                            <div class="title">Session Summary</div>
                            <div class="subtitle">Timing offsets per note (ms)</div>
                            <div id="timingChart" style="width:100%;height:160px;"></div>
                            <div class="summary-grid">
                                <div class="summary-stat">
                                    <div class="label">Accuracy</div>
                                    <div class="value" id="sum-acc">0%</div>
                                </div>
                                <div class="summary-stat">
                                    <div class="label">Combo Max</div>
                                    <div class="value" id="sum-combo">0</div>
                                </div>
                                <div class="summary-stat">
                                    <div class="label">Hits</div>
                                    <div class="value" id="sum-hits">0</div>
                                </div>
                                <div class="summary-stat">
                                    <div class="label">Misses</div>
                                    <div class="value" id="sum-miss">0</div>
                                </div>
                            </div>
                            <div class="summary-actions">
                                <button id="summaryContinue">Continue</button>
                                <button id="summaryRetry" class="primary">Retry</button>
                            </div>
                        </div>
                    </div>
                    <div class="countin-overlay" id="countInOverlay">
                        <div class="countin-number" id="countInNumber"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        (function () {
            // Constants and helpers
            const TICKS_PER_QUARTER = 12; // support triplets and standard subdivisions
            const STORAGE_KEY = 'rhythm_practice_settings_v1';

            const difficultyConfig = {
                easy: {
                    // Simpler: quarters only
                    allowedDurTicks: [4],
                    restChance: 0.18,
                    toleranceMs: 180,
                    firstBeatBonusMs: 80
                },
                medium: {
                    // Previous easy
                    allowedDurTicks: [4, 2], // quarter, eighth
                    restChance: 0.12,
                    toleranceMs: 120,
                    firstBeatBonusMs: 60
                },
                hard: {
                    // Slightly easier than before: drop sixteenths, keep dotted eighths
                    allowedDurTicks: [4, 3, 2],
                    restChance: 0.18,
                    toleranceMs: 75,
                    firstBeatBonusMs: 45
                }
            };

            function clamp(v, a, b) { return Math.min(b, Math.max(a, v)); }
            function lerp(a, b, t) { return a + (b - a) * t; }
            function parseTimeSig(ts) { const [n, d] = ts.split('/').map(Number); return { n, d }; }
            function saveSettings(obj) { try { localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); } catch { } }
            function loadSettings() { try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); } catch { return {}; } }

            // DOM
            const el = {
                bpm: document.getElementById('bpm'),
                measures: document.getElementById('measures'),
                timeSig: document.getElementById('timeSig'),
                difficulty: document.getElementById('difficulty'),
                metronome: document.getElementById('metronome'),
                countIn: document.getElementById('countIn'),
                btnGenerate: document.getElementById('generate'),
                btnPlay: document.getElementById('play'),
                btnStop: document.getElementById('stop'),
                btnReset: document.getElementById('reset'),
                sheet: document.getElementById('sheet'),
                canvasWrap: document.querySelector('.canvas-wrap'),
                startOverlay: document.getElementById('startOverlay'),
                startHint: document.getElementById('startHint'),
                countInOverlay: document.getElementById('countInOverlay'),
                countInNumber: document.getElementById('countInNumber'),
                summaryOverlay: document.getElementById('summaryOverlay'),
                summaryRetry: document.getElementById('summaryRetry'),
                summaryContinue: document.getElementById('summaryContinue'),
                timingChart: document.getElementById('timingChart'),
                statAcc: document.getElementById('stat-acc'),
                statHits: document.getElementById('stat-hits'),
                statMiss: document.getElementById('stat-miss'),
                statCombo: document.getElementById('stat-combo'),
                progressFill: document.getElementById('progressFill'),
                feedback: document.getElementById('timingFeedback')
            };

            function isVisible(node) {
                if (!node) return false;
                const d = window.getComputedStyle(node).display;
                return d !== 'none';
            }

            // Canvas setup
            const ctx = el.sheet.getContext('2d');
            let canvasWidth = 0, canvasHeight = 0, dpr = 1;
            function getMeasuresPerRow() {
                // Determine number of measures per row responsively (1..4)
                const leftPad = 64, rightPad = 12;
                const usable = Math.max(100, canvasWidth - leftPad - rightPad);
                const minMeasurePx = 240; // minimum visual width per measure on small screens
                const mpr = Math.floor(usable / minMeasurePx);
                return Math.max(1, Math.min(4, mpr));
            }
            function sizeCanvasWrap() {
                const wrap = document.querySelector('.canvas-wrap');
                if (!wrap) return;
                const rect = wrap.getBoundingClientRect();
                const bottomPad = 20;
                const h = Math.max(240, Math.floor(window.innerHeight - rect.top - bottomPad));
                wrap.style.height = `${h}px`;
            }
            function resizeCanvas() {
                sizeCanvasWrap();
                const rect = el.sheet.getBoundingClientRect();
                canvasWidth = Math.max(600, Math.floor(rect.width));
                // Dynamic height based on rows (max 4 measures per row)
                const lineSpacing = 16;
                const topPad = 28;
                const bottomPad = 36;
                let computedHeight = 280;
                if (pattern) {
                    const staffHeight = lineSpacing * 4;
                    const measuresPerRow = getMeasuresPerRow();
                    const measureTicks = pattern.ticksPerBeat * pattern.timeSig.beatsPerMeasure;
                    const totalMeasures = Math.ceil(pattern.totalTicks / measureTicks);
                    const numRows = Math.max(1, Math.ceil(totalMeasures / measuresPerRow));
                    const rowStride = staffHeight + 60;
                    computedHeight = topPad + numRows * rowStride + bottomPad;
                }
                canvasHeight = computedHeight;
                dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
                el.sheet.width = canvasWidth * dpr;
                el.sheet.height = canvasHeight * dpr;
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                drawSheet();
            }
            window.addEventListener('resize', resizeCanvas);

            // Audio engine
            let audioCtx = null;
            async function ensureAudio() {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state !== 'running') {
                    try { await audioCtx.resume(); } catch { }
                }
            }
            let scheduledMetronome = [];
            function clickAt(time, isAccent) {
                if (!el.metronome.checked) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(isAccent ? 1000 : 800, time);
                gain.gain.setValueAtTime(0.0001, time);
                gain.gain.exponentialRampToValueAtTime(0.25, time + 0.001);
                gain.gain.exponentialRampToValueAtTime(0.0001, time + 0.08);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start(time);
                osc.stop(time + 0.12);
                scheduledMetronome.push({ osc, gain, stopAt: time + 0.12 });
            }

            function stopAllScheduledMetronome(nowTime) {
                const now = nowTime ?? (audioCtx ? audioCtx.currentTime : 0);
                for (const ev of scheduledMetronome) {
                    try {
                        ev.osc.stop(now + 0.001);
                        ev.gain.disconnect();
                    } catch { }
                }
                scheduledMetronome = [];
            }

            // State
            let pattern = null; // { measures, timeSig, totalTicks, items: [{startTick, durTicks, isRest, state, hitDeltaMs}], ticksPerBeat }
            let schedule = null; // { startTime, events: [seconds], endTime, countInBeats }
            let isPlaying = false;
            let rafId = 0;
            let nextEventIdx = 0;
            let stats = { hits: 0, misses: 0, combo: 0 };
            let maxCombo = 0;
            let accSamples = []; // {t: secondsFromStart, acc: 0..1}
            let timingPlot = null; // uPlot instance for summary
            let timingResizeHandler = null;
            let autoScrollRow = -1;
            let lastHitAtSec = -Infinity;
            const HIT_COOLDOWN_SEC = 0.12;

            // Pattern generation
            function generatePattern() {
                const bpm = clamp(Number(el.bpm.value || 100), 30, 240);
                const allowedMeasures = [1, 4, 16, 32];
                let mInput = Number(el.measures.value || 4);
                const measures = allowedMeasures.includes(mInput) ? mInput : 4;
                const { n: beatsPerMeasure, d: beatNote } = parseTimeSig(el.timeSig.value);
                const diff = difficultyConfig[el.difficulty.value] || difficultyConfig.easy;

                const ticksPerBeat = Math.round((4 / beatNote) * TICKS_PER_QUARTER);
                const measureTicks = beatsPerMeasure * ticksPerBeat;
                const items = [];
                const ts = { beatsPerMeasure, beatNote };
                const beamGroupTicks = (beatNote === 8 && (beatsPerMeasure % 3 === 0))
                    ? ticksPerBeat * 3
                    : ticksPerBeat;

                // Define duration palette based on difficulty
                const DUR = {
                    whole: ticksPerBeat * 4,
                    half: ticksPerBeat * 2,
                    quarter: ticksPerBeat,
                    eighth: Math.round(ticksPerBeat / 2),
                    tripletEighth: Math.round(ticksPerBeat / 3),
                    dottedQuarter: Math.round(ticksPerBeat * 1.5),
                    dottedEighth: Math.round(ticksPerBeat * 0.75)
                };

                const isSimpleMeter = (beatNote === 2 || beatNote === 4);

                for (let m = 0; m < measures; m++) {
                    let t = 0;
                    while (t < measureTicks) {
                        const posInMeasure = m * measureTicks + t;
                        const inBeat = t % ticksPerBeat;

                        if (el.difficulty.value === 'medium' && isSimpleMeter && inBeat === 0 && (measureTicks - t) >= ticksPerBeat && Math.random() < 0.45) {
                            // Insert an eighth-note triplet group for this beat, sometimes with missing notes
                            const tripletRestProb = 0.35;
                            const restFlags = [0, 1, 2].map(() => Math.random() < tripletRestProb);
                            if (restFlags.every(v => v)) {
                                // Ensure at least one note present
                                const keepIdx = Math.floor(Math.random() * 3);
                                restFlags[keepIdx] = false;
                            }
                            for (let i = 0; i < 3; i++) {
                                const isRest = !!restFlags[i];
                                items.push({ startTick: m * measureTicks + t, durTicks: DUR.tripletEighth, isRest, state: 'pending', hitDeltaMs: null, isTriplet: true, isDotted: false });
                                t += DUR.tripletEighth;
                            }
                            continue;
                        }

                        // Build allowed durations for this difficulty
                        let allowed = [];
                        if (el.difficulty.value === 'easy') {
                            allowed = [DUR.whole, DUR.half, DUR.quarter, DUR.eighth];
                        } else if (el.difficulty.value === 'medium') {
                            allowed = [DUR.quarter, DUR.eighth];
                        } else {
                            // hard: allow dotted values as well
                            allowed = [DUR.half, DUR.quarter, DUR.eighth, DUR.dottedQuarter, DUR.dottedEighth];
                        }

                        // Filter to fit remaining measure
                        allowed = allowed.filter(dur => t + dur <= measureTicks);
                        // Avoid crossing beam-group for short values only
                        allowed = allowed.filter(dur => (dur >= ticksPerBeat) || (((t % beamGroupTicks) + dur) <= beamGroupTicks));

                        if (allowed.length === 0) allowed = [measureTicks - t];

                        let dur = allowed[Math.floor(Math.random() * allowed.length)];

                        // Bias towards quarters on easy
                        if (el.difficulty.value === 'easy' && dur !== DUR.quarter && Math.random() < 0.85 && allowed.includes(DUR.quarter)) {
                            dur = DUR.quarter;
                        }

                        const isRest = Math.random() < diff.restChance;
                        const isDotted = (dur === DUR.dottedQuarter) || (dur === DUR.dottedEighth);
                        items.push({ startTick: m * measureTicks + t, durTicks: dur, isRest, state: 'pending', hitDeltaMs: null, isTriplet: false, isDotted });
                        t += dur;
                    }
                }

                pattern = { measures, timeSig: { beatsPerMeasure, beatNote }, totalTicks: measures * measureTicks, items, ticksPerBeat };
                nextEventIdx = items.findIndex(i => !i.isRest);
                if (nextEventIdx < 0) nextEventIdx = 0;
                stats = { hits: 0, misses: 0, combo: 0 };
                updateStats();
                buildSchedule();
                // Ensure canvas resizes to new multi-row height before drawing
                resizeCanvas();
            }

            // Build schedule from pattern and settings
            function buildSchedule() {
                if (!pattern) return;
                const bpm = clamp(Number(el.bpm.value || 100), 30, 240);
                const secondsPerQuarter = 60 / bpm;
                const secondsPerTick = secondsPerQuarter / TICKS_PER_QUARTER;

                const countInBeats = el.countIn.checked ? pattern.timeSig.beatsPerMeasure : 0;
                const events = pattern.items.map(it => it.startTick * secondsPerTick);
                const durationSeconds = pattern.totalTicks * secondsPerTick;
                schedule = { startTimeAudio: 0, startTimeVisual: 0, events, endTimeAudio: 0, endTimeVisual: 0, countInBeats, secondsPerTick, secondsPerQuarter };
            }

            // Playback
            async function startPlayback() {
                if (!pattern) generatePattern();
                await ensureAudio();
                buildSchedule();
                const nowAudio = audioCtx.currentTime;
                const nowVisual = performance.now() / 1000;
                const { beatsPerMeasure } = pattern.timeSig;
                const secondsPerBeat = schedule.secondsPerQuarter * (4 / pattern.timeSig.beatNote);
                const baseTimeAudio = nowAudio + 0.15;
                const baseTimeVisual = nowVisual + 0.15;
                const countInBeats = el.countIn.checked ? beatsPerMeasure : 0;
                schedule.startTimeAudio = baseTimeAudio + countInBeats * secondsPerBeat;
                schedule.endTimeAudio = schedule.startTimeAudio + (pattern.totalTicks * schedule.secondsPerTick);
                schedule.startTimeVisual = baseTimeVisual + countInBeats * secondsPerBeat;
                schedule.endTimeVisual = schedule.startTimeVisual + (pattern.totalTicks * schedule.secondsPerTick);

                // Reset states
                pattern.items.forEach(i => { i.state = 'pending'; i.hitDeltaMs = null; });
                stats = { hits: 0, misses: 0, combo: 0 };
                maxCombo = 0;
                accSamples = [];
                autoScrollRow = -1;
                nextEventIdx = pattern.items.findIndex(i => !i.isRest);
                if (nextEventIdx < 0) nextEventIdx = 0;
                updateStats();
                el.progressFill.style.width = '0%';
                if (el.startOverlay) el.startOverlay.style.display = 'none';
                if (el.canvasWrap) el.canvasWrap.style.overflowY = 'auto';

                // Clear any prior scheduled clicks before scheduling new ones
                stopAllScheduledMetronome(nowAudio);

                // Schedule metronome
                if (el.metronome.checked) {
                    // Count-in clicks + visual
                    let t = baseTimeAudio;
                    if (el.countIn.checked) {
                        if (el.countInOverlay) {
                            el.countInOverlay.style.display = 'flex';
                        }
                        for (let b = 0; b < beatsPerMeasure; b++) {
                            clickAt(t, b === 0);
                            if (el.countInNumber) {
                                // Update number shortly before the click
                                const displayAt = t - 0.01;
                                setTimeout(() => {
                                    el.countInNumber.textContent = String(beatsPerMeasure - b);
                                }, Math.max(0, (displayAt - audioCtx.currentTime) * 1000));
                            }
                            t += secondsPerBeat;
                        }
                        // Hide number at start
                        setTimeout(() => {
                            if (el.countInOverlay) el.countInOverlay.style.display = 'none';
                            if (el.countInNumber) el.countInNumber.textContent = '';
                        }, Math.max(0, (schedule.startTimeAudio - audioCtx.currentTime) * 1000));
                    }
                    // Measure + beats over entire piece
                    let totalBeats = Math.round(pattern.totalTicks / pattern.ticksPerBeat);
                    t = schedule.startTimeAudio;
                    for (let b = 0; b <= totalBeats + 1; b++) {
                        clickAt(t, (b % beatsPerMeasure) === 0);
                        t += secondsPerBeat;
                        if (t > schedule.endTimeAudio + 0.5) break;
                    }
                }

                isPlaying = true;
                loop();
            }

            function stopPlayback() {
                isPlaying = false;
                if (rafId) cancelAnimationFrame(rafId);
                if (audioCtx) stopAllScheduledMetronome(audioCtx.currentTime);
                if (audioCtx && audioCtx.state === 'running') {
                    // Keep context for next play to avoid iOS relock; do not close
                }

                if (el.startOverlay) el.startOverlay.style.display = 'flex';
                if (el.canvasWrap) { el.canvasWrap.scrollTop = 0; el.canvasWrap.style.overflowY = 'hidden'; }
                // Ensure no scheduled metronome remains
                if (audioCtx) stopAllScheduledMetronome(audioCtx.currentTime);
                drawSheet();
            }

            function loop() {
                if (!isPlaying) return;
                const audioRunning = audioCtx && audioCtx.state === 'running';
                const now = audioRunning ? audioCtx.currentTime : (performance.now() / 1000);
                const startSec = audioRunning ? schedule.startTimeAudio : schedule.startTimeVisual;
                const endSec = audioRunning ? schedule.endTimeAudio : schedule.endTimeVisual;
                const t = now - startSec;
                const progress = clamp(t / (endSec - startSec), 0, 1);
                if (el.progressFill) {
                    el.progressFill.style.width = `${(progress * 100).toFixed(1)}%`;
                }
                // Sample accuracy approx 20Hz (cumulative: hits / (hits + misses))
                if (!accSamples._last || now - accSamples._last >= 0.05) {
                    accSamples._last = now;
                    const attempts = stats.hits + stats.misses;
                    const acc = attempts > 0 ? (stats.hits / attempts) : 0;
                    accSamples.push({ t: Math.max(0, now - startSec), acc });
                }

                // Auto-miss overdue events
                autoMiss(now);
                drawSheet(now);

                if (now >= endSec + 0.05) {
                    isPlaying = false;
                    if (audioCtx) stopAllScheduledMetronome(audioCtx.currentTime);

                    drawSheet();
                    showSummary();
                    return;
                }
                rafId = requestAnimationFrame(loop);
            }

            function autoMiss(now) {
                const diff = difficultyConfig[el.difficulty.value] || difficultyConfig.easy;
                const tol = diff.toleranceMs / 1000;
                while (nextEventIdx < pattern.items.length) {
                    const it = pattern.items[nextEventIdx];
                    if (it.isRest) { nextEventIdx++; continue; }
                    const audioRunning = audioCtx && audioCtx.state === 'running';
                    const startSec = audioRunning ? schedule.startTimeAudio : schedule.startTimeVisual;
                    const eventTime = startSec + it.startTick * schedule.secondsPerTick;
                    if (now > eventTime + tol) {
                        // Missed
                        it.state = 'miss';
                        it.hitDeltaMs = null;
                        stats.misses += 1;
                        stats.combo = 0;
                        updateStats();
                        nextEventIdx++;
                        continue;
                    }
                    break;
                }
            }

            // Input handling
            function onHitInput() {
                if (!pattern || !schedule) return;
                ensureAudio();
                const audioRunning = audioCtx && audioCtx.state === 'running';
                const now = audioRunning ? audioCtx.currentTime : (performance.now() / 1000);
                if (now - lastHitAtSec < HIT_COOLDOWN_SEC) return;
                const diff = difficultyConfig[el.difficulty.value] || difficultyConfig.easy;
                const baseTolMs = diff.toleranceMs;
                const firstBonusMs = diff.firstBeatBonusMs || 0;
                const maxWindowFactor = 2.5;
                const measureTicks = pattern.ticksPerBeat * pattern.timeSig.beatsPerMeasure;
                const startSec = audioRunning ? schedule.startTimeAudio : schedule.startTimeVisual;
                const nowTick = Math.max(0, (now - startSec) / schedule.secondsPerTick);
                const nowMeasure = Math.floor(nowTick / measureTicks);

                // Find next pending note
                let idx = nextEventIdx;
                while (idx < pattern.items.length && pattern.items[idx].isRest) idx++;
                if (idx >= pattern.items.length) return;
                const it = pattern.items[idx];
                const eventMeasure = Math.floor(it.startTick / measureTicks);
                // Anti-skip: do not allow advancing beyond the current measure
                if (eventMeasure > nowMeasure) {
                    return;
                }
                // proceed with grading
                const eventTime = startSec + it.startTick * schedule.secondsPerTick;
                const delta = now - eventTime; // + late, - early
                const isFirstInMeasure = (it.startTick % measureTicks) === 0;
                const tolSec = (baseTolMs + (isFirstInMeasure ? firstBonusMs : 0)) / 1000;
                const badWindowSec = ((baseTolMs * maxWindowFactor) + (isFirstInMeasure ? firstBonusMs : 0)) / 1000;

                let feedbackText = '';
                if (Math.abs(delta) <= tolSec) {
                    // Good
                    it.state = 'good';
                    it.hitDeltaMs = Math.round(delta * 1000);
                    stats.hits += 1;
                    stats.combo += 1;
                    if (stats.combo > maxCombo) maxCombo = stats.combo;
                    feedbackText = `On time (${Math.abs(it.hitDeltaMs)}ms)`;
                    if (el.feedback) el.feedback.innerHTML = `<span class="good">${feedbackText}</span>`;
                    nextEventIdx = idx + 1;
                    lastHitAtSec = now;
                } else if (Math.abs(delta) <= badWindowSec) {
                    // Early/Late (bad) but still consume to progress
                    it.state = 'bad';
                    it.hitDeltaMs = Math.round(delta * 1000);
                    stats.misses += 1;
                    stats.combo = 0;
                    const dir = delta < 0 ? 'Early' : 'Late';
                    feedbackText = `${dir} by ${Math.abs(it.hitDeltaMs)}ms`;
                    if (el.feedback) el.feedback.innerHTML = `<span class="warn">${feedbackText}</span>`;
                    nextEventIdx = idx + 1;
                    lastHitAtSec = now;
                } else {
                    // Ignore far-off taps
                    return;
                }
                updateStats();
                drawSheet(now);
            }

            // Notation helpers
            const NOTEHEAD_RX = 7.5;
            const NOTEHEAD_RY = 5.5;
            const STEM_LEN = 36;
            const BEAM_THICK = 4;
            const BEAM_GAP = 3;

            function getBeamCount(durTicks, ticksPerBeat) {
                if (durTicks >= ticksPerBeat) return 0; // quarter or longer
                // We only use eighths and triplet-eighths â†’ 1 beam
                return 1;
            }

            function drawNotehead(x, y, color, filled) {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(-20 * Math.PI / 180);
                ctx.beginPath();
                ctx.ellipse(0, 0, NOTEHEAD_RX, NOTEHEAD_RY, 0, 0, Math.PI * 2);
                if (filled) {
                    ctx.fillStyle = color;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.restore();
            }

            function drawDot(x, y, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x + NOTEHEAD_RX + 6, y - 2, 2.2, 0, Math.PI * 2);
                ctx.fill();
            }

            function drawStemUp(x, y, color) {
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + NOTEHEAD_RX - 1, y - 1);
                ctx.lineTo(x + NOTEHEAD_RX - 1, y - STEM_LEN);
                ctx.stroke();
                return { stemX: x + NOTEHEAD_RX - 1, stemTopY: y - STEM_LEN };
            }

            function drawBeamQuad(x1, y1, x2, y2, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineTo(x2, y2 + BEAM_THICK);
                ctx.lineTo(x1, y1 + BEAM_THICK);
                ctx.closePath();
                ctx.fill();
            }

            function drawFlagUp(stemX, stemTopY, beamIndex, color) {
                // Curved flag approximating standard engraving
                const y0 = stemTopY + (beamIndex - 1) * (BEAM_THICK + BEAM_GAP);
                const height = 10;
                const width = 12;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(stemX, y0);
                ctx.bezierCurveTo(
                    stemX + width * 0.4, y0 + 2,
                    stemX + width, y0 + 1,
                    stemX + width, y0 + height * 0.6
                );
                ctx.bezierCurveTo(
                    stemX + width * 0.9, y0 + height,
                    stemX + width * 0.35, y0 + height * 0.9,
                    stemX, y0 + height
                );
                ctx.closePath();
                ctx.fill();
            }

            function drawQuarterRest(x, y, color) {
                // Stylized quarter rest: diagonal zig with small curl
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 2, y - 12);
                ctx.lineTo(x - 4, y - 6);
                ctx.lineTo(x + 2, y);
                ctx.lineTo(x - 4, y + 6);
                ctx.stroke();
            }

            function drawEighthRest(x, y, color) {
                // More accurate eighth rest approximation
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x, y - 12);
                ctx.quadraticCurveTo(x + 8, y - 10, x + 2, y - 5);
                ctx.moveTo(x + 2, y - 5);
                ctx.quadraticCurveTo(x - 2, y + 2, x - 2, y + 8);
                ctx.stroke();
            }

            function drawSixteenthRest(x, y, color) {
                drawEighthRest(x, y, color);
                ctx.beginPath();
                ctx.moveTo(x + 1, y - 7);
                ctx.quadraticCurveTo(x + 6, y - 5, x + 1, y - 2);
                ctx.stroke();
            }

            function drawHalfRest(x, staffY, lineSpacing, color) {
                // Half rest sits on the middle line
                const midLineY = staffY + lineSpacing * 2;
                ctx.fillStyle = color;
                ctx.fillRect(x - 6, midLineY - 4, 12, 4);
            }

            function drawWholeRest(x, staffY, lineSpacing, color) {
                // Whole rest hangs from the line below the middle (4th from top)
                const lineBelowMid = staffY + lineSpacing * 3;
                ctx.fillStyle = color;
                ctx.fillRect(x - 6, lineBelowMid, 12, 4);
            }

            // Drawing
            function drawSheet(now) {
                if (!pattern) { clearCanvas(); drawEmpty(); return; }
                clearCanvas();

                const leftPad = 64;
                const rightPad = 12;
                const topPad = 28;
                const bottomPad = 36;
                const lineSpacing = 16;
                const measureTicks = pattern.ticksPerBeat * pattern.timeSig.beatsPerMeasure;
                const measuresPerRow = getMeasuresPerRow();
                const totalMeasures = Math.ceil(pattern.totalTicks / measureTicks);
                const numRows = Math.max(1, Math.ceil(totalMeasures / measuresPerRow));
                const usableWidth = canvasWidth - leftPad - rightPad;
                const ticksPerRow = measuresPerRow * measureTicks;
                const pxPerTickRow = usableWidth / ticksPerRow;
                const staffHeight = lineSpacing * 4;
                const rowStride = staffHeight + 60;

                // Precompute row meta
                const rows = [];
                for (let r = 0; r < numRows; r++) {
                    const rowStartMeasure = r * measuresPerRow;
                    const rowMeasures = Math.min(measuresPerRow, totalMeasures - rowStartMeasure);
                    const rowStartTick = rowStartMeasure * measureTicks;
                    const staffY = topPad + r * rowStride;
                    const midLineY = staffY + lineSpacing * 2;
                    const rowBarXs = [];
                    for (let m = 0; m <= rowMeasures; m++) {
                        rowBarXs.push(leftPad + m * measureTicks * pxPerTickRow);
                    }
                    rows.push({ r, staffY, midLineY, rowStartTick, rowMeasures, rowBarXs });
                }

                function adjustAwayFromBar(x, barXs) {
                    let nearest = null;
                    let minD = Infinity;
                    for (const bx of barXs) {
                        const d = Math.abs(x - bx);
                        if (d < minD) { minD = d; nearest = bx; }
                    }
                    const minDist = NOTEHEAD_RX + 3;
                    if (nearest != null && Math.abs(x - nearest) < minDist) {
                        const smallOffset = 4; // nudge notehead slightly right of barline for visibility
                        return nearest + smallOffset;
                    }
                    return x;
                }

                // Staff lines per row
                ctx.strokeStyle = 'rgba(255,255,255,0.14)';
                ctx.lineWidth = 1;
                for (const row of rows) {
                    for (let i = 0; i < 5; i++) {
                        const y = row.staffY + i * lineSpacing;
                        ctx.beginPath();
                        ctx.moveTo(leftPad, y);
                        ctx.lineTo(canvasWidth - rightPad, y);
                        ctx.stroke();
                    }
                }

                // Time signature only on first row
                if (rows[0]) {
                    const row0 = rows[0];
                    ctx.fillStyle = 'rgba(229,231,235,0.9)';
                    ctx.font = 'bold 24px ui-monospace, Menlo, Monaco, SFMono-Regular, Consolas, Liberation Mono, monospace';
                    ctx.textAlign = 'right';
                    ctx.fillText(String(pattern.timeSig.beatsPerMeasure), leftPad - 10, row0.staffY + lineSpacing * 1.5);
                    ctx.fillText(String(pattern.timeSig.beatNote), leftPad - 10, row0.staffY + lineSpacing * 3.5);
                    ctx.textAlign = 'left';
                }

                // Measure bars per row
                for (const row of rows) {
                    for (let m = 0; m <= row.rowMeasures; m++) {
                        const x = leftPad + m * measureTicks * pxPerTickRow;
                        ctx.beginPath();
                        ctx.moveTo(x, row.staffY - 8);
                        ctx.lineTo(x, row.staffY + lineSpacing * 4 + 8);
                        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                    }
                }

                // Build note layout with rows
                const layouts = [];
                for (let i = 0; i < pattern.items.length; i++) {
                    const it = pattern.items[i];
                    const rowIdx = Math.floor(it.startTick / ticksPerRow);
                    const row = rows[Math.min(rowIdx, rows.length - 1)];
                    const ticksIntoRow = it.startTick - row.rowStartTick;
                    let x = leftPad + ticksIntoRow * pxPerTickRow;
                    x = adjustAwayFromBar(x, row.rowBarXs);
                    const beamCount = getBeamCount(it.durTicks, pattern.ticksPerBeat);
                    layouts.push({ i, x, y: row.midLineY, it, beamCount, stemX: null, stemTopY: null, connectedLeft: {}, connectedRight: {}, row });
                }

                // Notes/rests (noteheads first)
                for (const l of layouts) {
                    const it = l.it;
                    const color = it.state === 'good' ? 'rgba(34,197,94,1)'
                        : it.state === 'miss' ? 'rgba(239,68,68,1)'
                            : it.state === 'bad' ? 'rgba(245,158,11,1)'
                                : 'rgba(229,231,235,1)';
                    if (it.isRest) {
                        const tpb = pattern.ticksPerBeat;
                        if (it.durTicks >= tpb * 4) {
                            drawWholeRest(l.x, l.row.staffY, lineSpacing, color);
                            if (it.isDotted) drawDot(l.x, l.row.midLineY, color);
                        } else if (it.durTicks >= tpb * 2) {
                            drawHalfRest(l.x, l.row.staffY, lineSpacing, color);
                            if (it.isDotted) drawDot(l.x, l.row.midLineY, color);
                        } else if (it.durTicks >= tpb) {
                            drawQuarterRest(l.x, l.row.midLineY, color);
                            if (it.isDotted) drawDot(l.x, l.row.midLineY, color);
                        } else if (it.durTicks >= Math.round(tpb / 2)) {
                            drawEighthRest(l.x, l.row.midLineY, color);
                            if (it.isDotted) drawDot(l.x, l.row.midLineY, color);
                        } else {
                            // Triplet or smaller â†’ show as eighth rest
                            drawEighthRest(l.x, l.row.midLineY, color);
                            if (it.isDotted) drawDot(l.x, l.row.midLineY, color);
                        }
                    } else {
                        const filled = it.durTicks < (pattern.ticksPerBeat * 2); // half and whole unfilled
                        drawNotehead(l.x, l.y, color, filled);
                        if (it.isDotted) drawDot(l.x, l.y, color);
                    }
                }

                // Stems
                for (const l of layouts) {
                    if (l.it.isRest) continue;
                    const isWhole = l.it.durTicks >= (pattern.ticksPerBeat * 4);
                    if (isWhole) continue; // whole notes have no stems
                    const color = l.it.state === 'good' ? 'rgba(34,197,94,1)'
                        : l.it.state === 'miss' ? 'rgba(239,68,68,1)'
                            : l.it.state === 'bad' ? 'rgba(245,158,11,1)'
                                : 'rgba(229,231,235,1)';
                    const stem = drawStemUp(l.x, l.y, color);
                    l.stemX = stem.stemX;
                    l.stemTopY = stem.stemTopY;
                }

                // Beam connectivity within groups
                const ts = pattern.timeSig;
                const beamGroupTicks = (ts.beatNote === 8 && (ts.beatsPerMeasure % 3 === 0))
                    ? pattern.ticksPerBeat * 3
                    : pattern.ticksPerBeat;
                function sameBeamGroup(a, b) {
                    // Same local beam group and same row
                    return a.row === b.row && (Math.floor(a.it.startTick / beamGroupTicks) === Math.floor(b.it.startTick / beamGroupTicks));
                }
                for (let i = 0; i < layouts.length - 1; i++) {
                    const A = layouts[i], B = layouts[i + 1];
                    if (A.it.isRest || B.it.isRest) continue;
                    if (!sameBeamGroup(A, B)) continue;
                    const minBeams = Math.min(A.beamCount, B.beamCount);
                    for (let b = 1; b <= minBeams; b++) {
                        A.connectedRight[b] = true;
                        B.connectedLeft[b] = true;
                    }
                }

                // Draw beams
                for (let i = 0; i < layouts.length - 1; i++) {
                    const A = layouts[i], B = layouts[i + 1];
                    if (A.it.isRest || B.it.isRest) continue;
                    if (!sameBeamGroup(A, B)) continue;
                    const minBeams = Math.min(A.beamCount, B.beamCount);
                    if (minBeams <= 0) continue;
                    const color = 'rgba(229,231,235,1)';
                    for (let b = 1; b <= minBeams; b++) {
                        const yA = A.stemTopY + (b - 1) * (BEAM_THICK + BEAM_GAP);
                        const yB = B.stemTopY + (b - 1) * (BEAM_THICK + BEAM_GAP);
                        drawBeamQuad(A.stemX, yA, B.stemX, yB, color);
                    }
                }

                // Flags where no beam
                for (const L of layouts) {
                    if (L.it.isRest) continue;
                    const color = L.it.state === 'good' ? 'rgba(34,197,94,1)'
                        : L.it.state === 'miss' ? 'rgba(239,68,68,1)'
                            : L.it.state === 'bad' ? 'rgba(245,158,11,1)'
                                : 'rgba(229,231,235,1)';
                    for (let b = 1; b <= L.beamCount; b++) {
                        const hasConn = L.connectedLeft[b] || L.connectedRight[b];
                        if (!hasConn) drawFlagUp(L.stemX, L.stemTopY, b, color);
                    }
                }

                // Triplet count markers (monospace '3' above group)
                for (let i = 0; i < layouts.length;) {
                    const L = layouts[i];
                    if (!L.it.isTriplet) { i++; continue; }
                    const group = [L];
                    let j = i + 1;
                    while (j < layouts.length && layouts[j].it.isTriplet && Math.floor(layouts[j].it.startTick / pattern.ticksPerBeat) === Math.floor(L.it.startTick / pattern.ticksPerBeat)) {
                        group.push(layouts[j]);
                        j++;
                        if (group.length === 3) break;
                    }
                    if (group.length === 3) {
                        const x1 = group[0].x;
                        const x3 = group[2].x;
                        const fallbackY = (group[0].row ? group[0].row.staffY : (topPad)) - 12;
                        const yTop = Math.min(group[0].stemTopY || fallbackY, group[1].stemTopY || fallbackY, group[2].stemTopY || fallbackY) - 6;
                        ctx.fillStyle = 'rgba(229,231,235,0.9)';
                        ctx.font = '12px ui-monospace, Menlo, Monaco, SFMono-Regular, Consolas, Liberation Mono, monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('3', (x1 + x3) / 2, yTop);
                        i = j;
                    } else {
                        i++;
                    }
                }

                // (Removed secondary debug note render)

                // Playhead mapped to current row
                if (isPlaying && now != null) {
                    const audioRunning = audioCtx && audioCtx.state === 'running';
                    const startSec = audioRunning ? schedule.startTimeAudio : schedule.startTimeVisual;
                    const t = now - startSec;
                    const progressTicks = clamp(t / schedule.secondsPerTick, 0, pattern.totalTicks);
                    const rowIdx = Math.floor(progressTicks / ticksPerRow);
                    const row = rows[Math.min(Math.max(0, rowIdx), rows.length - 1)];
                    const ticksIntoRow = progressTicks - row.rowStartTick;
                    const x = leftPad + ticksIntoRow * pxPerTickRow;
                    ctx.strokeStyle = 'rgba(96,165,250,0.9)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, row.staffY - 12);
                    ctx.lineTo(x, row.staffY + lineSpacing * 4 + 16);
                    ctx.stroke();

                    // Auto-scroll sheet to keep current row in view
                    if (autoScrollRow !== row.r) {
                        const wrap = el.canvasWrap || document.querySelector('.canvas-wrap');
                        if (wrap) {
                            const targetTop = Math.max(0, Math.floor(row.staffY - 24));
                            wrap.scrollTo({ top: targetTop, behavior: 'smooth' });
                            autoScrollRow = row.r;
                        }
                    }
                }

                // Bottom labels (monospace)
                ctx.fillStyle = 'rgba(229,231,235,0.7)';
                ctx.font = '12px ui-monospace, Menlo, Monaco, SFMono-Regular, Consolas, Liberation Mono, monospace';
                ctx.fillText(`${pattern.timeSig.beatsPerMeasure}/${pattern.timeSig.beatNote}`, leftPad, canvasHeight - 10);
                const acc = calcAccuracy();
                ctx.textAlign = 'right';
                ctx.fillText(`${acc.toFixed(0)}%`, canvasWidth - rightPad, canvasHeight - 10);
                ctx.textAlign = 'left';
            }

            function clearCanvas() {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            }

            function drawEmpty() {
                ctx.fillStyle = 'rgba(229,231,235,0.5)';
                ctx.font = '14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
                ctx.fillText('Press Start to begin a new session', 20, 40);
            }

            // Stats
            function calcAccuracy() {
                const totalTargets = pattern ? pattern.items.filter(i => !i.isRest).length : 0;
                const acc = totalTargets > 0 ? (stats.hits / totalTargets) * 100 : 0;
                return acc;
            }

            function updateStats() {
                const acc = calcAccuracy();
                if (el.statAcc) el.statAcc.textContent = `${acc.toFixed(0)}%`;
                if (el.statHits) el.statHits.textContent = `${stats.hits}`;
                if (el.statMiss) el.statMiss.textContent = `${stats.misses}`;
                if (el.statCombo) el.statCombo.textContent = `${stats.combo}`;
            }

            // Summary
            function showSummary() {
                // Hide sidebar (optional per request)
                const container = document.querySelector('.container');
                if (container) container.classList.add('no-sidebar');

                // Populate metrics
                const acc = calcAccuracy();
                const sumAcc = document.getElementById('sum-acc');
                const sumHits = document.getElementById('sum-hits');
                const sumMiss = document.getElementById('sum-miss');
                const sumCombo = document.getElementById('sum-combo');
                if (sumAcc) sumAcc.textContent = `${acc.toFixed(0)}%`;
                if (sumHits) sumHits.textContent = String(stats.hits);
                if (sumMiss) sumMiss.textContent = String(stats.misses);
                if (sumCombo) sumCombo.textContent = String(maxCombo);

                // Show overlay before measuring for chart sizing
                if (el.summaryOverlay) el.summaryOverlay.style.display = 'flex';
                if (el.canvasWrap) { el.canvasWrap.scrollTop = 0; el.canvasWrap.style.overflowY = 'hidden'; }
                document.body.style.overflow = 'hidden';

                // Build timing offsets and render with uPlot
                if (el.timingChart && window.uPlot) {
                    const noteOffsets = pattern.items
                        .filter(it => !it.isRest)
                        .map((it, idx) => ({ idx: idx + 1, ms: (typeof it.hitDeltaMs === 'number') ? it.hitDeltaMs : null }));

                    const xVals = noteOffsets.map(o => o.idx);
                    const yVals = noteOffsets.map(o => (o.ms == null ? null : o.ms));

                    const absVals = yVals.filter(v => v != null).map(v => Math.abs(v));
                    const base = absVals.length ? Math.max(...absVals) : 60;
                    const maxAbs = Math.min(300, Math.max(80, Math.ceil(base * 1.1)));
                    const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#60a5fa';

                    const container = el.timingChart;
                    const rect = container.getBoundingClientRect();
                    const width = Math.max(320, Math.floor(rect.width || window.innerWidth * 0.9));
                    const height = Math.max(140, Math.floor(parseFloat(container.style.height) || 160));

                    const makePlot = () => new uPlot({
                        width,
                        height,
                        title: '',
                        scales: {
                            x: { time: false },
                            y: {
                                range: () => [-maxAbs, maxAbs]
                            }
                        },
                        axes: [
                            {
                                grid: { show: true },
                                stroke: 'rgba(255,255,255,0.5)',
                                ticks: { show: false },
                                values: () => []
                            },
                            {
                                grid: { show: true },
                                stroke: 'rgba(255,255,255,0.5)'
                            }
                        ],
                        cursor: { drag: { x: false, y: false } },
                        legend: { show: false },
                        hooks: {
                            draw: [u => {
                                const ctx = u.ctx;
                                const { top, left, width: bw, height: bh } = u.bbox;
                                // Zero baseline
                                const y0 = Math.round(u.valToPos(0, 'y', true)) + 0.5;
                                ctx.save();
                                ctx.strokeStyle = 'rgba(255,255,255,0.25)';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(left, y0);
                                ctx.lineTo(left + bw, y0);
                                ctx.stroke();
                                // Vertical grid line for each note
                                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                                ctx.lineWidth = 1;
                                for (let i = 0; i < xVals.length; i++) {
                                    const px = Math.round(u.valToPos(xVals[i], 'x', true)) + 0.5;
                                    ctx.beginPath();
                                    ctx.moveTo(px, top);
                                    ctx.lineTo(px, top + bh);
                                    ctx.stroke();
                                }
                                ctx.restore();
                            }]
                        },
                        series: [
                            {},
                            {
                                stroke: accent,
                                width: 2,
                                spanGaps: true,
                                points: { show: false }
                            }
                        ]
                    }, [xVals, yVals], container);

                    // Destroy previous plot and resize handler if present
                    if (timingPlot) { try { timingPlot.destroy(); } catch { } timingPlot = null; }
                    if (timingResizeHandler) { window.removeEventListener('resize', timingResizeHandler); timingResizeHandler = null; }

                    timingPlot = makePlot();

                    // Responsive resize while overlay is visible
                    timingResizeHandler = () => {
                        if (!el.summaryOverlay || el.summaryOverlay.style.display === 'none' || !timingPlot) return;
                        const r = container.getBoundingClientRect();
                        const w = Math.max(320, Math.floor(r.width));
                        timingPlot.setSize({ width: w, height });
                    };
                    window.addEventListener('resize', timingResizeHandler);
                }
            }

            // Persistence
            function getSettings() {
                return {
                    bpm: Number(el.bpm.value),
                    measures: Number(el.measures.value),
                    timeSig: el.timeSig.value,
                    difficulty: el.difficulty.value,
                    metronome: el.metronome.checked,
                    countIn: el.countIn.checked
                };
            }
            function applySettings(data) {
                if (!data) return;
                if (data.bpm) el.bpm.value = clamp(Number(data.bpm), 30, 240);
                if (data.measures) {
                    const allowedMeasures = [1, 4, 16, 32];
                    const mv = Number(data.measures);
                    el.measures.value = String(allowedMeasures.includes(mv) ? mv : 4);
                }
                if (data.timeSig) el.timeSig.value = data.timeSig;
                if (data.difficulty) el.difficulty.value = data.difficulty;
                if (typeof data.metronome === 'boolean') el.metronome.checked = data.metronome;
                if (typeof data.countIn === 'boolean') el.countIn.checked = data.countIn;
                // Sync custom UI controls if present
                const bpmValNode = document.getElementById('bpmVal');
                if (bpmValNode) bpmValNode.textContent = String(el.bpm.value);
                if (window._syncPills) window._syncPills();
            }

            // Events
            el.btnStop.addEventListener('click', () => { stopPlayback(); });
            el.btnReset.addEventListener('click', () => {
                if (!pattern) return;
                pattern.items.forEach(i => { if (!i.isRest) { i.state = 'pending'; i.hitDeltaMs = null; } });
                stats = { hits: 0, misses: 0, combo: 0 };
                nextEventIdx = pattern.items.findIndex(i => !i.isRest);
                if (nextEventIdx < 0) nextEventIdx = 0;
                el.feedback.textContent = '';
                updateStats();
                drawSheet();
            });

            // Start overlay interactions
            function attemptStartFromOverlay(target) {
                if (!el.startOverlay) return;
                const inControls = target && target.closest && target.closest('.start-bar');
                if (!inControls) { generatePattern(); resizeCanvas(); startPlayback(); }
            }
            if (el.startHint) {
                el.startHint.addEventListener('click', (e) => { attemptStartFromOverlay(e.target); });
            }
            if (el.startOverlay) {
                el.startOverlay.addEventListener('click', (e) => { attemptStartFromOverlay(e.target); });
                el.startOverlay.addEventListener('touchstart', (e) => { attemptStartFromOverlay(e.target); }, { passive: true });
            }

            // Build pill selectors and BPM slider UI
            (function initStartUI() {
                const bpmValNode = document.getElementById('bpmVal');
                if (bpmValNode) {
                    bpmValNode.textContent = String(el.bpm.value);
                    el.bpm.addEventListener('input', () => { bpmValNode.textContent = String(el.bpm.value); });
                }

                function makePills(container, values, getLabel, current, onSelect) {
                    if (!container) return [];
                    container.innerHTML = '';
                    const pills = values.map(v => {
                        const s = document.createElement('span');
                        s.className = 'pill' + (String(v) === String(current) ? ' active' : '');
                        s.textContent = getLabel(v);
                        s.tabIndex = 0;
                        s.addEventListener('click', () => onSelect(v, s));
                        s.addEventListener('keydown', (e) => { if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); onSelect(v, s); } });
                        container.appendChild(s);
                        return s;
                    });
                    return pills;
                }

                function syncActive(buttons, current, mapVal = (x) => x) {
                    buttons.forEach(btn => {
                        const val = btn.textContent;
                        const isActive = String(mapVal(val)) === String(current);
                        btn.classList.toggle('active', isActive);
                    });
                }

                // Measures limited set
                const measuresGroup = document.getElementById('measuresGroup');
                let measureButtons = [];
                if (measuresGroup) {
                    const measureVals = [1, 4, 16, 32];
                    measureButtons = makePills(measuresGroup, measureVals, v => String(v), el.measures.value, (v, btn) => {
                        el.measures.value = String(v);
                        measureButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        saveSettings(getSettings());
                    });
                }

                // Time signature from hidden select
                const timeSigGroup = document.getElementById('timeSigGroup');
                let timeSigButtons = [];
                if (timeSigGroup && el.timeSig) {
                    const tsVals = Array.from(el.timeSig.options).map(o => o.value);
                    timeSigButtons = makePills(timeSigGroup, tsVals, v => v, el.timeSig.value, (v, btn) => {
                        el.timeSig.value = v;
                        timeSigButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        saveSettings(getSettings());
                    });
                }

                // Difficulty from hidden select
                const difficultyGroup = document.getElementById('difficultyGroup');
                let difficultyButtons = [];
                if (difficultyGroup && el.difficulty) {
                    const diffVals = Array.from(el.difficulty.options).map(o => o.value);
                    function label(v) { return v.charAt(0).toUpperCase() + v.slice(1); }
                    difficultyButtons = makePills(difficultyGroup, diffVals, label, el.difficulty.value, (v, btn) => {
                        el.difficulty.value = v;
                        difficultyButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        saveSettings(getSettings());
                    });
                }

                // Expose a sync for applySettings
                window._syncPills = function () {
                    if (measureButtons.length) {
                        measureButtons.forEach((b) => b.classList.toggle('active', b.textContent === String(el.measures.value)));
                    }
                    if (timeSigButtons.length) {
                        timeSigButtons.forEach((b) => b.classList.toggle('active', b.textContent === el.timeSig.value));
                    }
                    if (difficultyButtons.length) {
                        difficultyButtons.forEach((b) => b.classList.toggle('active', b.textContent.toLowerCase() === el.difficulty.value));
                    }
                    const bv = document.getElementById('bpmVal');
                    if (bv) bv.textContent = String(el.bpm.value);
                };
            })();

            // Summary actions
            // Retry: run same pattern again immediately
            el.summaryRetry.addEventListener('click', async () => {
                // Cleanup chart & listeners before leaving summary
                if (timingResizeHandler) { window.removeEventListener('resize', timingResizeHandler); timingResizeHandler = null; }
                if (timingPlot) { try { timingPlot.destroy(); } catch { } timingPlot = null; }
                if (el.summaryOverlay) el.summaryOverlay.style.display = 'none';
                document.body.style.overflow = '';
                if (el.canvasWrap) el.canvasWrap.style.overflowY = 'auto';
                // Ensure overlays hidden
                if (el.startOverlay) el.startOverlay.style.display = 'none';
                // Do not regenerate; reuse current pattern
                await startPlayback();
            });

            // Continue: go back to Start/options panel
            el.summaryContinue.addEventListener('click', () => {
                // Cleanup chart & listeners before leaving summary
                if (timingResizeHandler) { window.removeEventListener('resize', timingResizeHandler); timingResizeHandler = null; }
                if (timingPlot) { try { timingPlot.destroy(); } catch { } timingPlot = null; }
                if (el.summaryOverlay) el.summaryOverlay.style.display = 'none';
                if (el.startOverlay) el.startOverlay.style.display = 'flex';
                document.body.style.overflow = '';
                if (el.canvasWrap) { el.canvasWrap.scrollTop = 0; el.canvasWrap.style.overflowY = 'hidden'; }
            });

            // Auto-save on setting changes
            ['bpm', 'measures', 'timeSig', 'difficulty', 'metronome', 'countIn'].forEach(id => {
                const node = el[id];
                node.addEventListener('change', () => saveSettings(getSettings()));
                if (node.type === 'number' || node.type === 'range' || node.tagName === 'SELECT') {
                    node.addEventListener('input', () => saveSettings(getSettings()));
                }
            });

            // Input: space / tap
            let preventRepeat = false;
            document.addEventListener('keydown', (e) => {
                const k = e.key || e.code;
                if (k === ' ' || k === 'Space' || k === 'Spacebar') {
                    e.preventDefault();
                    if (!preventRepeat) {
                        // If summary visible, ignore space
                        if (isVisible(el.summaryOverlay)) {
                            preventRepeat = true;
                            return;
                        }
                        if (!isPlaying) {
                            generatePattern();
                            startPlayback();
                        } else {
                            onHitInput();
                        }
                        preventRepeat = true;
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                const k = e.key || e.code;
                if (k === ' ' || k === 'Space' || k === 'Spacebar') {
                    preventRepeat = false;
                }
            });
            el.sheet.addEventListener('mousedown', (e) => {
                if (isVisible(el.summaryOverlay)) return;
                onHitInput();
            });
            el.sheet.addEventListener('touchstart', (e) => {
                if (isVisible(el.summaryOverlay)) return;
                onHitInput();
            }, { passive: true });

            // Init
            applySettings(loadSettings());
            sizeCanvasWrap();
            resizeCanvas();
            generatePattern();
            // Show start overlay initially
            el.startOverlay.style.display = 'flex';
            if (el.canvasWrap) { el.canvasWrap.scrollTop = 0; el.canvasWrap.style.overflowY = 'hidden'; }
        })();
    </script>
</body>

</html>